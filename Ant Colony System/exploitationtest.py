import numpy as np

np.random.seed(0)
n = 6 # number of cities
cl = 2 # length of candidate list
m = 4 # num ants
beta = 2
alpha = rho = tau0 = 0.1
q_0 = 1

def take_candidates(j, dist_mat):  # looks at city j and returns candidate list of cl closest cities to j
    return list(np.argsort(dist_mat[j])[1:cl+1])

def take_remaining(j,dist_mat):
    return list(np.argsort(dist_mat[j])[cl:])

dist_mat = [[0, 1.4, 1.5, 2.3, 4, 4.2],
            [1.4, 0, 1.6, 4, 1.8, 3.5],
            [1.5, 1.6, 0, 3.2, 1.7, 5],
            [2.3, 4, 3.2, 0, 1.8, 1.6],
            [4, 1.8, 1.7, 1.8, 0, 1.5],
            [4.2, 3.5, 5, 1.6, 1.5, 0]]

candidate_list = {r: take_candidates(r, dist_mat) for r in range(n)}
eta = {r: [1/dist_mat[r][s] for s in take_candidates(r, dist_mat)] for r in range(n)}
print(candidate_list)
position = {i: None for i in range(m)}
pheromone = {r: [tau0]*cl for r in range(n)}
available_positions = {i: [j for j in range(n)] for i in range(m)}

position = {0: 2, 1: 5, 2: 1, 3: 0}

tour_distance = {i: 0.0 for i in range(m)} 
tour = {i: [] for i in range(m)}

for ant in range(len(available_positions)): # removing starting city of each ant from their list of available cities 
    del(available_positions[ant][position[ant]])
r_k = position.copy()
overlap = {x: list(set(available_positions[x]) & set(candidate_list[position[x]])) for x in range(len(position))}

for step in range(n):
    if step < n - 1:
        overlap = {x: list(set(available_positions[x]) & set(candidate_list[position[x]])) for x in range(len(position))}
        print('overlap: ',overlap)
        for ant in range(len(position)):
            print('ant number', ant)
            print('length of overlap: ', len(overlap[ant]))
            if len(overlap[ant]) > 0:
                overlap_pheromone = []
                overlap_eta = []
                for overlap_city in overlap[ant]:
                    print(overlap_city)
                    print(candidate_list)
                    candidate_idx = candidate_list[r_k[ant]].index(overlap_city)
                    overlap_pheromone.append(pheromone[r_k[ant]][candidate_idx])
                    overlap_eta.append(eta[r_k[ant]][candidate_idx])
                print('overlap pheromone: ', overlap_pheromone)
                print('overlap eta: ', overlap_eta)
                poss_transitions = overlap_pheromone*np.power(overlap_eta, beta)
                q = np.random.rand()
                
                # exploitation case
                if q <= q_0:
                    s = max(poss_transitions)
                    position[ant] = overlap[ant][np.where(poss_transitions == s)[0][0]]
                
                # exploration case
                else: 
                    summed_trans = sum(poss_transitions)
                    # generates list of probabilities that sum to 1 be pseudo-randomly picked
                    prob_array = [i / summed_trans for i in poss_transitions]
                    n = len(poss_transitions)
                    idx = np.random.choice(list(range(n)), p=prob_array)
                    position[ant] = overlap[ant][idx]
                trans_idx = candidate_list[r_k[ant]].index(position[ant])
                #LOCAL
                pheromone[r_k[ant]][trans_idx] = (1 - rho) * pheromone[r_k[ant]][trans_idx] + rho * tau0 
            
            else: 
                print('no overlap')
                next_best = take_remaining(r_k[ant], dist_mat)
                remaining_overlap = list(set(available_positions[ant]) & set(next_best))
                position[ant] = remaining_overlap[0]
            tour[ant].append((r_k[ant], position[ant]))
            tour_distance[ant] += dist_mat[r_k[ant], position[ant]]
            r_k[ant] = position[ant]
            del_idx = available_positions[ant].index(position[ant])
            del(available_positions)[ant][del_idx]
